:time_estimate: 5

= Provision Edge Devices Using the RHEL Installer

_Estimated reading time: *{time_estimate} minutes*._

Objective::
Provision edge devices using bootc containers and a customized RHEL installation media.

WARNING: Work in progress

== Using bootc image builder

After you build a bootc container image and publish it in an OCI container registry, you can use bootc image builder to create different kinds of bootable disk images embedding the bootc container image.

image::s1-bib-iso-fig-1.svg["Workflow from building bootc container images to provisioning edge devices, with highlight on the usage of bootc image builder."]

Bootc image builder takes tree inputs:

* The name of a bootc container image, which was already downloaded (pulled) into the local containers storage.

* A configuration file in the TOML format, which defines customizations to be applied to the bootable disk image.

* An output directory, where it saves the bootable disk image and a number of temporary files.

Bootc image builder is provided as an application container image, which you MUST run as a privileged container.
That means it is not very friendly to developer workflows, especially in organizations which restrict privileges of developers on their own work machines and continuous integration (CI) servers.
Bootc image builder is positioned as a system administrator tool.

This is a typical Podman command to run booc image builder.
First, we focus on the arguments to Podman itself.

[source,subs="verbatim,quotes"]
--
$ sudo podman run --rm -it \ <1>
    --privileged --security-opt label=type:unconfined_t \ <2>
    -v /var/lib/containers/storage:/var/lib/containers/storage \ <3>
    -v $(pwd)/config.toml:/config.toml \ <4>
    -v $(pwd)/output:/output \ <5>
    registry.redhat.io/rhel10/bootc-image-builder \ <6>
    _command line options for bootc image builder_ \
    _command line arguments for bootc image builder_ \
--
<1> Run an interactive container, and remove the container when it ternminates.
<2> Run a privileged container, with an unconfined SELinux context.
<3> Mount the system containers storage, which is the one for the root user.
<4> Mount the TOML configuration file for bootc image builder.
<5> Mount the output directory.
<6> Name of the bootc image builder application container.

To download (pull) the bootc image builder application container from Red Hat, you need a valid Red Hat customer portal account, which can be a free Red Hat Developer account.

NOTE: You do NOT need to run bootc image builder from the Red Hat registry.
You can copy it to a private registry inside your organization's network, and run it from there.

Now we focus on the arguments to bootc image builder:

[source,subs="verbatim,quotes"]
--
$ sudo podman run _command line options for podman_ \
    registry.redhat.io/rhel10/bootc-image-builder \
    --type iso \ <1>
    --config /config.toml \ <2>
    registry.example.com/mybootc:tag <3>
--
<1> Type of disk image to generate, in this case an ISO installation media for RHEL.
<2> Name of the TOML configuration file, which must match the name used in the `-v` option for Podman.
<3> Name of the bootc container container image to embed in the disk image.

The bootc container image must be previously downloaded to the system containers storage, that is, you must run:

[source,subs="verbatim,quotes"]
--
$ sudo podman pull registry.example.com/mybootc:tag
--

Before attempting to run booc image builder.

Because you do not install bootc image builder from an RPM package, you will not find man pages for it.
Fortunately, its application container accepts the usual `--help` command line option.

[source,subs="verbatim,quotes"]
--
$ sudo podman run --rm \
    registry.redhat.io/rhel10/bootc-image-builder \
    --help

Create a bootable image from an ostree native container

Usage:
  bootc-image-builder [command]

Available Commands:
  build       Create a bootable image from an ostree native container (default command)
  completion  Generate the autocompletion script for the specified shell
  help        Help about any command
  manifest    Only create the manifest but don't build the image.
  version     Show the version and quit

Flags:
  -h, --help               help for bootc-image-builder
      --log-level string   logging level (debug, info, error); default error
  -v, --verbose            Switch to verbose mode
      --version            version for bootc-image-builder

Use "bootc-image-builder [command] --help" for more information about a command.
--

Most of the time you will use the default `build` command from bootc image builder, and you can get help for that command as:

[source,subs="verbatim,quotes"]
--
$ sudo podman run --rm \
  registry.redhat.io/rhel10/bootc-image-builder \
  build --help

Create a bootable image from an ostree native container
(default action if no command is given)
IMAGE_NAME: container image to build into a bootable image

Usage:
  bootc-image-builder build IMAGE_NAME

Examples:
bootc-image-builder build quay.io/centos-bootc/centos-bootc:stream9
bootc-image-builder quay.io/centos-bootc/centos-bootc:stream9


Flags:
      --aws-ami-name string      name for the AMI in AWS (only for type=ami)
      --aws-bucket string        target S3 bucket name for intermediate storage when creating AMI (only for type=ami)
      --aws-region string        target region for AWS uploads (only for type=ami)
...
--

Of course, you do not need to get help for bootc image builder as root, but there is no point downloading the bootc image builder application container to the containers storage of your regular, unprivileged Linux user because the `build` command requires a privileged container, which must be started as root.

== Customizations for ISO disk images

The `config.toml` given to bootc image builder contains a number of customizations to be applied to while generating a bootable disk image. 
The set of valid customizations varies with the kind of disk images and, in the case of an ISO image, the only valid customization is a kickstart script for Anaconda, the standard RHEL installation program.
So your `config.toml` file would be:

[source,subs="verbatim,quotes"]
--
[customizations.installer.kickstart]
contents = """
_your kickstart script_
"""
--

Your entire kickstart script is the value of the `contents` entry inside the `customizations.installer.kickstart` section, as long as it needs to be. 

You do not need to provide a complete kickstart script.
If you do not, Anaconda displays interactive screens for disk partitioning, local selection, etc.

IMPORTANT: You CANNOT include an `ostreecontainer` command on your kickstart file, because bootc image builder will prepend an `%include` instruction that refers to an automatically-generated kickstart script.
That autogeneretad script refers to the location of the bootc container image which is embedded in the ISO disk image.

== Day-1 customization with Anaconda

You could create a bootc container image which preconfigures applications and already embeds secrets (credentials) for acessing corporate systems, but this is not usual.
Most times, there are device-specific and site-specific configurations that you would perform at day-1, while provisioning edge devices.

You could also provide a kickstart script which configures everything required at day-1, including setting secrets, but this is not common either.
After all, the kickstart script, in USB media or a network server, would be an attack vector for getting such secrets.

The recommended process involves creating a short-lived user account, with an SSH key, which is used as part of an on-boarding process, and removed at the end of the process.
The on-boarding process sets site- and device-specific settings, and installs any secrets required to access local, corporate, and cloud services.

There are many ways of automating on-boarding process, which are out of scope for this course.
You will see sample kickstart scripts which configure an initial users with passwords and SSH keys.
By creating that user from kickstart instead of as part of a bootc container image, you can remove the user at the end of the on-boarding process.

It is usual, but not required, to provide a kickstart script which is complete regarding unattended installation, so Anaconda does not display any interactive installation screen and does not wait for any user input.
Such kickstart script would configure system settings such as timezone, keyboard layout, and disk partitioning.

You could have different kickstart scripts for each group of edge sites, for example to set different timezones and locates for different regions.
In this case, you would create different ISO images with bootc image builder, from the same bootc container image, and distribute them to each region.

The final preparation step, for provisioning physical edge devices, would be writing the ISO image to physical media, or copying it to a network boot server. 
In the former case, you could just use the `dd` command, using a raw device as the destination, or use specialized tools such as the Fedora Media Writer.

== What's next

The next lab creates a custom installation ISO and uses it to provision a local VM, demonstrating the process you would use to provision a physical edge device in disconnected mode.
